{
  "slug": "regex-wizard",
  "category": "coding",
  "title": "Regex Pattern Builder",
  "description": "Regex Pattern Builder prompt - Create and explain complex regex patterns for any use case. Never struggle with regular expressions again.",
  "tags": [
    "ChatGPT prompts",
    "Claude prompts",
    "free prompts",
    "technology prompts"
  ],
  "prompt": "You are a regex expert who can create, explain, and debug regular expressions for any use case. Make regex approachable by providing clear explanations and practical examples.\n\nI need a regex pattern for the following:\n\nREGEX REQUIREMENTS:\nWhat to Match: [DESCRIBE WHAT YOU WANT TO MATCH]\nWhat NOT to Match: [WHAT SHOULD BE EXCLUDED]\nLanguage/Tool: [JAVASCRIPT / PYTHON / PERL / GREP / SED / ETC]\nExamples of Valid Matches: [PROVIDE 3-5 EXAMPLES]\nExamples of Invalid Matches: [PROVIDE 3-5 EXAMPLES]\nSpecial Requirements: [CASE SENSITIVITY / MULTILINE / GLOBAL / ETC]\n\nPlease provide:\n\n1. THE REGEX PATTERN\nComplete pattern with explanation:\n```regex\n/[YOUR PATTERN HERE]/[FLAGS]\n```\n\nFor different flavors:\n- **JavaScript**: `/pattern/flags`\n- **Python**: `r\"pattern\"` with re.FLAGS\n- **PCRE/PHP**: `/pattern/flags`\n- **Java**: `Pattern.compile(\"pattern\", FLAGS)`\n- **.NET**: `new Regex(@\"pattern\", Options)`\n\n2. PATTERN BREAKDOWN\nExplain each part:\n```\n^                    # Start of string\n([A-Z])              # Group 1: Capital letter\n[a-z]+               # One or more lowercase letters\n(?:ing|ed|s)?        # Non-capturing group: optional suffix\n\\s*                  # Zero or more whitespace\n(\\d{2,4})            # Group 2: 2-4 digits\n$                    # End of string\n\nFull pattern: /^([A-Z])[a-z]+(?:ing|ed|s)?\\s*(\\d{2,4})$/\n```\n\n3. VISUAL EXPLANATION\nShow how it matches:\n```\nInput: \"Walking 2024\"\n       ^^^^^^^  ^^^^\n       |        |\n       |        └─ (\\d{2,4}) captures \"2024\"\n       └─ ([A-Z])[a-z]+(?:ing) matches \"Walking\"\n\n✅ MATCH\n\nInput: \"walk 24\"\n       ^^^^\n       |\n       └─ No capital letter at start\n       \n❌ NO MATCH\n```\n\n4. TEST CASES\nComprehensive testing:\n```javascript\n// Test data with expected results\nconst testCases = [\n    // Valid matches\n    { input: \"[example1]\", shouldMatch: true, groups: [\"group1\", \"group2\"] },\n    { input: \"[example2]\", shouldMatch: true, groups: [\"group1\", \"group2\"] },\n    \n    // Invalid matches\n    { input: \"[invalid1]\", shouldMatch: false },\n    { input: \"[invalid2]\", shouldMatch: false },\n    \n    // Edge cases\n    { input: \"\", shouldMatch: false },\n    { input: \"[edge case]\", shouldMatch: true/false }\n];\n\n// Test function\nfunction testRegex(pattern, testCases) {\n    testCases.forEach(test => {\n        const result = pattern.test(test.input);\n        const matches = test.input.match(pattern);\n        console.log(`Input: \"${test.input}\"`);\n        console.log(`Expected: ${test.shouldMatch}, Got: ${result}`);\n        if (matches) console.log(`Groups: ${matches.slice(1)}`);\n    });\n}\n```\n\n5. COMMON VARIATIONS\nAlternative patterns:\n```regex\n# Strict version (exact match):\n/^exact-pattern$/\n\n# Lenient version (partial match):\n/pattern/\n\n# Performance optimized:\n/(?:non-capturing|groups)/\n\n# Unicode support:\n/[\\u{1F600}-\\u{1F64F}]/u\n\n# Multiline mode:\n/^pattern$/m\n```\n\n6. REGEX FLAVORS\nHow it differs across languages:\n\n**JavaScript:**\n```javascript\nconst pattern = /your-pattern/gi;\nconst matches = text.match(pattern);\nconst replaced = text.replace(pattern, 'replacement');\n```\n\n**Python:**\n```python\nimport re\npattern = re.compile(r'your-pattern', re.IGNORECASE)\nmatches = pattern.findall(text)\nreplaced = pattern.sub('replacement', text)\n```\n\n**grep/sed:**\n```bash\n# grep with extended regex\ngrep -E 'pattern' file.txt\n\n# sed substitution\nsed 's/pattern/replacement/g' file.txt\n```\n\n7. PERFORMANCE OPTIMIZATION\nMake it faster:\n```regex\n# Avoid catastrophic backtracking:\n❌ Bad:  /(x+)+y/\n✅ Good: /x+y/\n\n# Use atomic groups when possible:\n(?>atomic-group)\n\n# Lazy vs Greedy:\n.*?  # Lazy (matches minimum)\n.*   # Greedy (matches maximum)\n\n# Anchors improve performance:\n^start  # Faster than searching entire string\n```\n\n8. DEBUGGING TIPS\nCommon issues and fixes:\n```\nProblem: Matches too much\nFix: Use lazy quantifiers (??, *?, +?)\n\nProblem: Doesn't match multiline\nFix: Add 'm' flag or use [\\s\\S] instead of .\n\nProblem: Case sensitivity\nFix: Add 'i' flag or use [Aa] for specific chars\n\nProblem: Special characters not working\nFix: Escape them: \\. \\* \\+ \\? \\[ \\] \\( \\) \\{ \\} \\| \\\\ \\^ \\$\n```\n\n9. REAL-WORLD EXAMPLES\nPractical applications:\n\n**Email Validation:**\n```regex\n/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/\n```\n\n**URL Extraction:**\n```regex\n/https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&//=]*)/g\n```\n\n**Phone Numbers:**\n```regex\n/(?:\\+?1[-.\\s]?)?\\(?([0-9]{3})\\)?[-.\\s]?([0-9]{3})[-.\\s]?([0-9]{4})/\n```\n\n10. ONLINE TOOLS\nTest and refine:\n- regex101.com - Test with explanations\n- regexr.com - Visual regex builder\n- regexpal.com - Simple tester\n- regexcrossword.com - Learn through puzzles\n\n11. CHEAT SHEET\nQuick reference:\n```\nANCHORS\n^     Start of string\n$     End of string\n\\b    Word boundary\n\\B    Not word boundary\n\nCHARACTER CLASSES\n.     Any character except newline\n\\d    Digit [0-9]\n\\D    Not digit\n\\w    Word character [A-Za-z0-9_]\n\\W    Not word character\n\\s    Whitespace\n\\S    Not whitespace\n\nQUANTIFIERS\n*     0 or more\n+     1 or more\n?     0 or 1\n{n}   Exactly n\n{n,}  n or more\n{n,m} Between n and m\n\nGROUPS\n(...)   Capturing group\n(?:...) Non-capturing group\n(?=...) Positive lookahead\n(?!...) Negative lookahead\n(?<=..) Positive lookbehind\n(?<!..) Negative lookbehind\n```\n\n12. REPLACEMENT PATTERNS\nUsing captured groups:\n```javascript\n// JavaScript\ntext.replace(/(first)(second)/, '$2 $1');  // Swap groups\n\n// Python\nre.sub(r'(\\w+) (\\w+)', r'\\2, \\1', text)  # Last, First\n\n// sed\nsed 's/\\(.*\\) \\(.*\\)/\\2 \\1/' file.txt\n```\n\nEnsure the regex is:\n- As simple as possible\n- Well-documented\n- Tested with edge cases\n- Performant for large inputs\n- Compatible with specified language"
}